# BddFeatures
bddfeatures_registrationfeaturecoding:
    question: |
        You've assembled a crack team for a brand new project:
        a site where paleontologists and other dinosaur scientists
        can send each other important scientific messages, along
        with the usual cat photos.

        Each scientist will need to register to gain access, and
        you - knowing that using BDD will create a better product -
        are writing a registration feature. Fill in the 4 feature
        lines in `registration.feature`.
    step: ~
    files:
        registration.feature: ~
    features:
        editor: ~
        browser: ~
    grading:
        #        $this->assertLineStartsWith(
        #            $lines,
        #            'Feature:',
        #            'a short feature description',
        #            0,
        #            false
        #        );
        check_line_1:
            type: behat
            # @TODO Implement file() function with ability to get specified line for Behat expression provider
            # @TODO Maybe start numering feature's lines from 1 instead of 0..? Not sure here
            assertTrue: file('registration.feature').line(1) matches /^Feature:/
            failure: a short feature description
        #        $this->assertLineStartsWith(
        #            $lines,
        #            'In order to',
        #            'your *business* value',
        #            1,
        #            true
        #        );
        check_line_2:
            type: behat
            assertTrue: file('registration.feature').line(2) matches /^In order to/
            failure: your *business* value
        #        $this->assertLineStartsWith(
        #            $lines,
        #            'As a',
        #            '*who* will benefit from the feature',
        #            2,
        #            true
        #        );
        check_line_3:
            type: behat
            assertTrue: file('registration.feature').line(3) matches /^As a/
            failure: your *business* value
        #        $this->assertLineStartsWith(
        #            $lines,
        #            'I need to be able to',
        #            'a short description of what the user will do with the feature',
        #            3,
        #            true
        #        );
        check_line_4:
            type: behat
            assertTrue: file('registration.feature').line(4) matches /^I need to be able to/
            failure: a short description of what the user will do with the feature

bddfeatures_bestbusinessvaluemc:
    question: |
        For the messaging feature, you and the intern (Bob) are in
        a heated debate over how to phrase the business value.
        Which if the following is the *best* business value for the
        message feature:
    explanation: |
        Business value is subjective. But to help, forget about the technology
        and think about the problem that your user role (scientist) wants to
        solve. Both "communicate" and "exchange information and resources"
        are pretty good business values, but I like the second, because it
        contains a few more details about what the scientists actually
        want to do.
    features:
        multiple_choice:
            choices:
                a: In order to type messages and click to send them to scientists.
                b: In order to communicate with other scientists.
                c: In order to exchange information and resources with other scientists.
                d: In order to send cat videos.
            correct: c

# Scenarios
scenarios_registrationscenariocoding:
    question: |
        After writing the feature for registration, the whole team
        (even Bob the intern!) is excited about BDD! Let's write the
        first scenario for our feature where we register successfully.
        After some conversation, you basically want it to work like this:

        1. You start on the homepage
        2. You click a link called "Register"
        3. You fill out an "Email" field and a "Password" field
        4. You press a "Register" button
        5. You see some text on the page, like "Hi Dr. Paleontology Person! Welcome!"

        Add a scenario that represents this, and compare your answer
        to ours. The most important thing is that you're using natural
        language.
    step: ~
    files:
        registration.feature: ~
    features:
        editor: ~
        browser: ~
    grading:
        check_scenarios:
            type: behat
            # @TODO Implement feature() function in order to get next info:
            # - .hasScenarios()
            # - .getScenario(1)
            # - .getScenario(1).getTitle()
            # - .getScenario(1).hasStep('Given')
            assertTrue: feature('registration.feature').hasScenarios()
            failure: I don't see *any* scenarios. Check your syntax on the scenario
        check_scenario_title:
            type: behat
            # @TODO Maybe start numering scenario from 1 instead of 0..? Not sure here
            assertFalse: feature('registration.feature').getScenario(1).getTitle() == ''
            failure: Make sure to put a short title after your scenario
        #        $steps = $scenario->getSteps();
        #        $hasGiven = false;
        #        $hasWhen = false;
        #        $hasThen = false;
        #        foreach ($steps as $step) {
        #            if ('Given' == $step->getType()) {
        #                $hasGiven = true;
        #            } elseif ('When' == $step->getType()) {
        #                $hasWhen = true;
        #            } elseif ('Then' == $step->getType()) {
        #                $hasThen = true;
        #            }
        #        }
        check_given:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('Given')
            failure: |
                I don't see a `Given` in your scenario: you probably want one to start on the "/" page
        check_when:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('When')
            failure: |
                I don't see a `When` in your scenario: you definitely need some, like for clicking Register, filling out the fields and pressing the submit button
        check_then:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('Then')
            failure: |
                I don't see a `Then` in your scenario: you probably want one where you check if the success message was shown

scenarios_badscenariomc:
    question: |
        Check out the following scenario. What's wrong here?

        ```gherkin
        Scenario: Sending a message
            Given there is a "dr_dino@example.com" user in the database
            And I am logged in as "dr_dino@example.com"
            And I am on "/"
            When I click "Send Message"
            And I fill in the message box with "Hello everyone!"
            And I press "Send"
            Then a message from "dr_dino@example.com" should be sent
        ```
    explanation: |
        In `Given`, you *can* "play god" and do things like database setup that your
        user cannot do. That's it's biggest purpose. But, it's also "ok" to take some
        user action - like logging in - when that user action really isn't central
        to what your scenario is really trying to do.

        The real problem is the `Then`: it is describing something that the user
        cannot see. What does it mean that the message "should be sent"? Unlike `Given`,
        we can't give the user super-powers here and allow them to "see" technical
        things, like messages being sent or database records being inserted.
    features:
        multiple_choice:
            choices:
                a: Actually, this scenario is perfect!
                b: In `Given`, you can only do things that the user can do. So, you can't magically "add a user to the database"
                c: In `Given`, you can't take user action. Saying "I am logged in as" implies that the user will go to the login page and login. This is user action and so should be under `When`.
                d: In `Then`, the user cannot see that a "message should be sent". The user would see some sort of a message, like "Your message has been sent" and we should look for this.
            correct: d

# UsingBehat
usingbehat_lsfeaturecoding:
    question: |
        Linus just told us about an edge case with the `ls` command:
        it does *not* show files starting with a `.` by default.
        To test for this, we've added two new scenarios that make sure
        that a `.dino` file only shows up with the `-a` option.

        Execute Behat from the command line, copy in the new step definition,
        and then fill in the contents so that our scenario passes.
    step: ~
    files:
        ls.feature: ~
        features/bootstrap/FeatureContext.php:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_scenarios:
            type: behat
            assertTrue: feature('ls.feature').hasScenarios()
            failure: I don't see *any* scenarios. Check your syntax on the scenario
        count_scenarios:
            type: behat
            assertFalse: feature('ls.feature').countScenarios() == 2
            failure: Make sure to create only a *2* new scenarios.
        check_first_scenario_title:
            type: behat
            assertFalse: feature('ls.feature').getScenario(1).getTitle() == ''
            failure: Make sure to put a short title after your first scenario.
        check_second_scenario_title:
            type: behat
            assertFalse: feature('ls.feature').getScenario(2).getTitle() == ''
            failure: Make sure to put a short title after your second scenario
        check_given_in_scenario_1:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('Given')
            failure: "I don't see a `Given` in your first scenario: you probably want one to have a hidden file starting with `.`."
        check_when_in_scenario_1:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('When')
            failure: "I don't see a `When` in your first scenario: you definitely need some, like for running commands in the terminal."
        check_then_in_scenario_1:
            type: behat
            assertTrue: feature('registration.feature').getScenario(1).hasStep('Then')
            failure: "I don't see a `Then` in your first scenario: you probably want one where you check if the success message was shown."
        check_given_in_scenario_2:
            type: behat
            assertTrue: feature('registration.feature').getScenario(2).hasStep('Given')
            failure: "I don't see a `Given` in your second scenario: you probably want one to have a hidden file starting with `.`."
        check_when_in_scenario_2:
            type: behat
            assertTrue: feature('registration.feature').getScenario(2).hasStep('When')
            failure: "I don't see a `When` in your second scenario: you definitely need some, like for running commands in the terminal."
        check_then_in_scenario_2:
            type: behat
            assertTrue: feature('registration.feature').getScenario(2).hasStep('Then')
            failure: "I don't see a `Then` in your second scenario: you probably want one where you check if the success message was shown."

usingbehat_independentscenariosmc:
    question: |
        The intern Bob is writing some scenarios that describe
        the behavior of the account area of our paleontology app.
        Do you see any problems with the second scenario?

        ```gherkin
        Scenario: Register
            Given I am on "/"
            When I fill in "email" with "dr_dino@example.com"
            And I fill in "password" with "roar"
            And I press "Register"
            Then I should see "You're registered!"

        Scenario: View my account area
            Given I am on "/login"
            When I fill in "email" with "dr_dino@example.com"
            And I fill in "password" with "roar"
            And I press "Login"
            And I click "My Account"
            Then I should see "My Account Information"
        ```
    explanation: |
        Each scenario should act completely independent of other scenarios.
        Right now, in order for scenario 2 to pass, you *must* run scenario 1
        first. This makes your scenarios very fragile and difficult to debug.

        Instead, the second scenario should make sure that the `dr_dino@example.com`
        user is in the database via a `Given` statement. We'll talk more about
        how to do this soon.
    features:
        multiple_choice:
            choices:
                a: |
                    The second scenario shouldn't start on `/login`, it should start
                    on `/` and then you should click a "Login" link.
                b: |
                    Scenario 2 uses the `dr_dino@example.com` user from scenario 1,
                    but each scenario should act completely independent of each other.
                c: |
                    The second scenario shouldn't need to repeat the email address
                    and password, since it is already in the first scenario.
            correct: b

# BehatHooksBackground
behathooksbackground_afterstephookcoding:
    question: |
        As a challenge, create a new function called `afterStepHook()` that
        is called after *every* individual step in a scenario. Inside of
        this, just execute `var_dump('After Step!');`.

        **Hint**
        See [hooking into the test process](http://docs.behat.org/en/v3.0/guides/3.hooks.html)
        for the annotation needed to do things after every step.
    step: ~
    files:
        features/bootstrap/FeatureContext.php: ~
        ls.feature:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_method:
            type: php
            assertTrue: reflection_class('FeatureContext').hasMethod('afterStepHook')
            failure: The `afterStepHook()` method wasn't found in the `FeatureContext` class.
        check_method_is_public:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').isPublic()
            failure: The `afterStepHook()` method should be public.
        assert_doc_comment:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').getDocComment() matches /@AfterStep/
            failure: You should to use `@AfterStep` annotation for `afterStepHook()` method.

behathooksbackground_checksteptestresultcoding:
    question: |
        Whenever you have a hook function, you're actually passed an `$event`
        argument object that contains information about what's happening inside Behat
        at this moment. The exact object depends on which hook you're using
        (see [Behat Hooks](http://docs.behat.org/en/v3.0/guides/3.hooks.html#hooks)).

        In `afterStepHook()`, add an `$event` argument and use it to figure out
        if the step that was just executed passed or failed. Replace `var_dump('After Step!')`
        with `var_dump($isPassed)` where `$isPassed` is equal to whether or not
        the previous step passed/failed.
    step: ~
    files:
        features/bootstrap/FeatureContext.php: ~
        ls.feature:
            read_only: true
    features:
        editor: ~
        browser: ~
    grading:
        check_method:
            type: php
            assertTrue: reflection_class('FeatureContext').hasMethod('afterStepHook')
            failure: The `afterStepHook()` method wasn't found in the `FeatureContext` class.
        check_method_is_public:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').isPublic()
            failure: The `afterStepHook()` method should be public.
        assert_doc_comment:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').getDocComment() matches /@AfterStep/
            failure: You should to use `@AfterStep` annotation for `afterStepHook()` method.
        assert_number_of_required_parameters:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').getNumberOfRequiredParameters() == 1
            failure: Make sure you give the `afterStepHook()` method exactly one argument.
        assert_parameter_name:
            type: php
            assertTrue: reflection_class('FeatureContext').getMethod('afterStepHook').getParameters()[0]->getName() == 'event'
            failure: Though you can really call it anything, let's call the argument to `afterStepHook()` `$event` for clarity.
